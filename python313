"""
Updte the below variables

bucket_name = 'daily-em'
key_prefix = 'Python-libs/'
"""
import os
import zipfile
import subprocess
import shutil
import boto3
import uuid
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

"""
The event for this function should be in the format below
===============================
{
    'library': 'library_name'
}
===============================
The function will return a signed URL of the created library in the 'download_url' part
of the returned json object
"""

def lambda_handler(event, context):
    try:
        # Get the library name from the event with proper error handling
        if not event or 'library' not in event:
            logger.error("Missing 'library' parameter in event")
            return {
                'statusCode': 400,
                'body': {
                    'message': "Missing required parameter 'library'"
                }
            }
        
        filename = event.get('library')
        pyversion = "python313"
        
        logger.info(f"Processing library: {filename} for Python version: {pyversion}")

        # Define paths and S3 info
        tmp_dir = f"/tmp/{filename}_package"
        zip_path = f"/tmp/{filename}_{pyversion}.zip"

        bucket_name = 'daily-em'
        key_prefix = 'Python-libs/'
        
        # The file name will be in the format Library_python313.zip
        s3_key = f"{key_prefix}{filename}_{pyversion}.zip"

        # Clean up from previous runs
        logger.info("Cleaning up temporary directories")
        shutil.rmtree(tmp_dir, ignore_errors=True)
        if os.path.exists(zip_path):
            os.remove(zip_path)
        os.makedirs(tmp_dir, exist_ok=True)

        # Install package to tmp_dir
        logger.info(f"Installing {filename} to {tmp_dir}")
        try:
            subprocess.check_call(['pip', 'install', '--target', tmp_dir, filename])
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to install {filename}: {str(e)}")
            return {
                'statusCode': 500,
                'body': {
                    'message': f"Failed to install {filename}. Error: {str(e)}"
                }
            }

        # Zip the installed package
        logger.info(f"Creating zip file at {zip_path}")
        try:
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, _, files in os.walk(tmp_dir):
                    for file in files:
                        abs_path = os.path.join(root, file)
                        rel_path = os.path.relpath(abs_path, tmp_dir)
                        zipf.write(abs_path, rel_path)
        except Exception as e:
            logger.error(f"Failed to create zip file: {str(e)}")
            return {
                'statusCode': 500,
                'body': {
                    'message': f"Failed to create zip file. Error: {str(e)}"
                }
            }

        # Upload to S3
        logger.info(f"Uploading to S3 bucket {bucket_name} with key {s3_key}")
        try:
            s3 = boto3.client('s3')
            s3.upload_file(zip_path, bucket_name, s3_key)
        except Exception as e:
            logger.error(f"Failed to upload to S3: {str(e)}")
            return {
                'statusCode': 500,
                'body': {
                    'message': f"Failed to upload to S3. Error: {str(e)}"
                }
            }

        # Generate pre-signed URL (valid for 1 hour)
        logger.info("Generating pre-signed URL")
        try:
            signed_url = s3.generate_presigned_url(
                'get_object',
                Params={'Bucket': bucket_name, 'Key': s3_key},
                ExpiresIn=3600
            )
        except Exception as e:
            logger.error(f"Failed to generate pre-signed URL: {str(e)}")
            return {
                'statusCode': 500,
                'body': {
                    'message': f"Failed to generate download URL. Error: {str(e)}"
                }
            }

        # Clean up temporary files to free Lambda storage
        logger.info("Cleaning up temporary files")
        shutil.rmtree(tmp_dir, ignore_errors=True)
        if os.path.exists(zip_path):
            os.remove(zip_path)

        logger.info(f"Successfully processed library: {filename}")
        return {
            'statusCode': 200,
            'body': {
                'message': f'{filename} library zipped and uploaded successfully',
                's3_key': s3_key,
                'download_url': signed_url
            }
        }
        
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return {
            'statusCode': 500,
            'body': {
                'message': f"An unexpected error occurred: {str(e)}"
            }
        }
